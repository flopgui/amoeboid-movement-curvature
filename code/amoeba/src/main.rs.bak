
use std::f32;
use rand_distr::StandardNormal;
use rand::prelude::*;
use rand_seeder::Seeder;
use rand_pcg::Pcg64;
use image::{RgbImage, Rgb};
use image::io::Reader as ImageReader;
use rayon::prelude::*;
use std::fs::{OpenOptions, read_dir};
use std::io::Write;
use libm;

const DOM_WIDTH: usize = 200;
const DOM_HEIGHT: usize = 200;
const DT: f32 = 0.0020; // temporal step 0.0025;
const DX: f32 = 0.15; // spatial step in um // old 0.1
const STOP_TIME: f32 = 500.0;
const SHIFT_DOMAIN: bool = true;
const HISTOGRAM_RESOLUTION: usize = 360;

// Phase field parameters
const RADIUS: f32 = 40.0;
const VOL: f32 = f32::consts::PI * RADIUS * RADIUS;
const THRESHOLD: f32 = 0.001;

// const ALPHA0: f32 = 3.0;     //Active force
// const ALPHA0: f32 = 1.2;     //Active force
const ALPHA0: f32 = 3.0;     //Active force
const EPSILON: f32 = 0.750;
// const GAMMA: f32 = 2.0;   //Tension of the membrane
const GAMMA: f32 = 1.8;   //Tension of the membrane
const TAU: f32 = 2.0;           //Time scale of the whole equation for the membrane dynamics
const MA: f32 = 0.5;     //Volume conservation
const MB: f32 = 1.0;            //Repulsion among cells

// Parameters for the Noise
const TAUXI: f32 = 10.0; // in s
const TAUXI_INV: f32 = 1.0 / TAUXI;
const SIGMA: f32 = 0.122474487;
const SIGMA2: f32 = SIGMA * SIGMA; // 0.015
const SEED: u64 = 787878;
// const MEMBRANE_NOISE: f32 = 0.25; //1.0 FOR the case of NO dependence on curvature, 0.4 for dependence
const MEMBRANE_NOISE: f32 = 0.5; //1.0 FOR the case of NO dependence on curvature, 0.4 for dependence
// const GLOBAL_NOISE: f32 = 0.0;
const GLOBAL_NOISE: f32 = 0.0;

// Parameters for Sawai Model
const D_B: f32 = 0.5 ; // in um2/s.
const DECAYX: f32 = 0.01; //
const KACT: f32 = 2.0; // 1.0	 //1.0 for Starving full movile cells and 0.2-0.5 for vegetative cells
const REACT: f32 = 1.0;

// Parameters of the activator conservation
const DELTA02: f32 = 0.5;
const VOL2: f32 = 0.25*VOL;
const RADIUS2: f32 = 0.5*RADIUS;
const TAUDELTA: f32 = 0.010 ;
const TAUMA: f32 = 1.0 ; // tauma = 0.010 ;

// const CURVATURE_LIMIT: f32 = 20.0;
const MIN_CURVATURE: f32 = 0.0;
const MAX_CURVATURE: f32 = 5.0;

type DomainMatrix = [[f32; DOM_HEIGHT]; DOM_WIDTH];

enum Shape {Circle, Flat, BumpyCircle}
const SHAPE: Shape = Shape::Circle;


fn distance(x1: f32, y1: f32, x2: f32, y2: f32) -> f32{
    ((x1 - x2).powi(2) + (y1 - y2).powi(2)).sqrt()
}

fn boundary_get(field: &DomainMatrix, x: usize, y: usize, dx: i32, dy: i32) -> f32{
    match SHAPE {
        Shape::Circle => periodic_border(field, x, y, dx, dy),
        Shape::Flat => semiperiodic_border(field, x, y, dx, dy),
        Shape::BumpyCircle => periodic_border(field, x, y, dx, dy),
    }
}

fn periodic_border(field: &DomainMatrix, x: usize, y: usize, dx: i32, dy: i32) -> f32{
    let px = (x as i32 + dx + DOM_WIDTH as i32) % (DOM_WIDTH as i32);
    let py = (y as i32 + dy + DOM_HEIGHT as i32) % (DOM_HEIGHT as i32);
    field[px as usize][py as usize]
}

fn semiperiodic_border(field: &DomainMatrix, x: usize, y: usize, dx: i32, dy: i32) -> f32{
    let px = (x as i32 + dx + DOM_WIDTH as i32) % (DOM_WIDTH as i32);
    let py = (y as i32 + dy).max(0).min(DOM_HEIGHT as i32 - 1);
    field[px as usize][py as usize]
}

fn gradient(u: &DomainMatrix, grad: &mut DomainMatrix) {
    // grad.par_iter_mut().enumerate().for_each(|(ix, row)| {
    //     for iy in 0..DOM_WIDTH {
    //         row[iy] = 
    //             ((boundary_get(&u, ix, iy, 1, 0) - boundary_get(&u, ix, iy, -1, 0)).powi(2) +
    //              (boundary_get(&u, ix, iy, 0, 1) - boundary_get(&u, ix, iy, 0, -1)).powi(2))
    //             .sqrt() / (2.0 * DX);
    //     }
    // })
    for ix in 0..DOM_WIDTH {
        for iy in 0..DOM_HEIGHT {
            grad[ix][iy] =
                ((boundary_get(&u, ix, iy, 1, 0) - boundary_get(&u, ix, iy, -1, 0)).powi(2) +
                 (boundary_get(&u, ix, iy, 0, 1) - boundary_get(&u, ix, iy, 0, -1)).powi(2))
                .sqrt() / (2.0 * DX);
        }
    }
}

fn laplacian(u: &DomainMatrix, lapl: &mut DomainMatrix) {
    lapl.par_iter_mut().enumerate().for_each(|(ix, row)| {
        for iy in 0..DOM_HEIGHT {
            row[iy] =
                (boundary_get(&u, ix, iy, 1, 0) + boundary_get(&u, ix, iy, -1, 0) +
                 boundary_get(&u, ix, iy, 0, 1) + boundary_get(&u, ix, iy, 0, -1) - 
                 4.0 * u[ix][iy]) / DX.powi(2);
        }
    })
    // for ix in 0..DOM_WIDTH {
    //     for iy in 0..DOM_HEIGHT {
    //         lapl[ix][iy] =
    //             (boundary_get(&u, ix, iy, 1, 0) + boundary_get(&u, ix, iy, -1, 0) +
    //              boundary_get(&u, ix, iy, 0, 1) + boundary_get(&u, ix, iy, 0, -1) - 
    //              4.0 * u[ix][iy]) / DX.powi(2);
    //     }
    // }
}

// Derivate phase field model: nabla*(phi nabla u)
fn derivate_phase_field(u: &DomainMatrix, phi: &DomainMatrix, out: &mut DomainMatrix) {
    out.par_iter_mut().enumerate().for_each(|(ix, row)| {
        for iy in 0..DOM_HEIGHT {
            let dphi_up = phi[ix][iy] + boundary_get(&phi, ix, iy, 0, 1);
            let dphi_down = phi[ix][iy] + boundary_get(&phi, ix, iy, 0, -1);
            let dphi_right = phi[ix][iy] + boundary_get(&phi, ix, iy, 1, 0);
            let dphi_left = phi[ix][iy] + boundary_get(&phi, ix, iy, -1, 0);
            row[iy] =
                (dphi_up * (boundary_get(&u, ix, iy, 0, 1) - u[ix][iy])
                 + dphi_down * (boundary_get(&u, ix, iy, 0, -1) - u[ix][iy])
                 + dphi_right * (boundary_get(&u, ix, iy, 1, 0) - u[ix][iy])
                 + dphi_left * (boundary_get(&u, ix, iy, -1, 0) - u[ix][iy]))
                * 0.5 / DX.powi(2);
        }
    })
    // for ix in 0..DOM_WIDTH {
    //     for iy in 0..DOM_HEIGHT {
    //         let dphi_up = phi[ix][iy] + boundary_get(&phi, ix, iy, 0, 1);
    //         let dphi_down = phi[ix][iy] + boundary_get(&phi, ix, iy, 0, -1);
    //         let dphi_right = phi[ix][iy] + boundary_get(&phi, ix, iy, 1, 0);
    //         let dphi_left = phi[ix][iy] + boundary_get(&phi, ix, iy, -1, 0);
    //         out[ix][iy] =
    //             (dphi_up * (boundary_get(&u, ix, iy, 0, 1) - u[ix][iy])
    //              + dphi_down * (boundary_get(&u, ix, iy, 0, -1) - u[ix][iy])
    //              + dphi_right * (boundary_get(&u, ix, iy, 1, 0) - u[ix][iy])
    //              + dphi_left * (boundary_get(&u, ix, iy, -1, 0) - u[ix][iy]))
    //             * 0.5 / DX.powi(2);
    //     }
    // }
}

fn curvature(u: &DomainMatrix, gradu: &DomainMatrix, out: &mut DomainMatrix, max_curv: &mut f32) {
    let mut unit_x: DomainMatrix = [[1.0; DOM_HEIGHT]; DOM_WIDTH];  // Phase field
    let mut unit_y: DomainMatrix = [[1.0; DOM_HEIGHT]; DOM_WIDTH];  // Phase field
    for ix in 0..DOM_WIDTH {
        for iy in 0..DOM_HEIGHT {
            if gradu[ix][iy] > 0.0001 {
                unit_x[ix][iy]= (boundary_get(u, ix, iy, 1, 0)-boundary_get(u, ix, iy, -1, 0))/(2.0*DX*gradu[ix][iy]);
                unit_y[ix][iy]= (boundary_get(u, ix, iy, 0, 1)-boundary_get(u, ix, iy, 0, -1))/(2.0*DX*gradu[ix][iy]);
            }
        }
    }
    for ix in 0..DOM_WIDTH {
        for iy in 0..DOM_HEIGHT {
            if gradu[ix][iy] > 0.005 {
                // let ux_p1 = if boundary_get(gradu, ix, iy, 1, 0) > 0.001 {(boundary_get(u, ix, iy, 2, 0) - u[ix][iy])/(DX*boundary_get(gradu, ix, iy, 1, 0))} else {0.0};
                // let ux_m1 = if boundary_get(gradu, ix, iy, -1, 0) > 0.001 {(u[ix][iy] - boundary_get(u, ix, iy, -2, 0))/(DX*boundary_get(gradu, ix, iy, -1, 0))} else {0.0};
                // let uy_p1 = if boundary_get(gradu, ix, iy, 0, 1) > 0.001 {(boundary_get(u, ix, iy, 0, 2) - u[ix][iy])/(DX*boundary_get(gradu, ix, iy, 0, 1))} else {0.0};
                // let uy_m1 = if boundary_get(gradu, ix, iy, 0, -1) > 0.001 {(u[ix][iy] - boundary_get(u, ix, iy, 0, -2))/(DX*boundary_get(gradu, ix, iy, 0, -1))} else {0.0};
                // out[ix][iy] = (ux_p1 - ux_m1 + uy_p1 - uy_m1) / DX;
                out[ix][iy] = (boundary_get(&unit_x, ix, iy, -1, 0) - boundary_get(&unit_x, ix, iy, 1, 0))/(2.0*DX) + (boundary_get(&unit_y, ix, iy, 0, -1) - boundary_get(&unit_y, ix, iy, 0, 1))/(2.0*DX);
                out[ix][iy] = out[ix][iy].min(100.0);
                *max_curv = max_curv.max(out[ix][iy]);
            } else {
                out[ix][iy] = 0.0;
            }
        }
    }
}

// Generation of field: circular
fn generate_field_circular(phi: &mut DomainMatrix, xcenter: f32, ycenter: f32, radius: f32) {
    for ix in 0..DOM_WIDTH {
        for iy in 0..DOM_HEIGHT {
            let r = DX * distance(xcenter, ycenter, ix as f32, iy as f32);
            phi[ix][iy] += 0.5 + 0.5 * ((radius - r) / (DX * EPSILON)).tanh();
        }
    }
}

fn initialize_circular(phi: &mut DomainMatrix, bct: &mut DomainMatrix, rng: &mut Pcg64) {
    let ro = RADIUS * DX;
    let xcenter = (DOM_WIDTH as f32)/2.0;
    let ycenter = (DOM_HEIGHT as f32)/2.0;
    generate_field_circular(phi, xcenter, ycenter, ro);
    let xran: f32 = -4.0 + 8.0*rng.gen::<f32>();
    let yran: f32 = -4.0 + 8.0*rng.gen::<f32>();
    generate_field_circular(bct, xcenter+xran+20.0, ycenter+yran, RADIUS2*DX);
}

fn initialize_bumpy_circle(phi: &mut DomainMatrix, bct: &mut DomainMatrix, rng: &mut Pcg64) {
    let xcenter = (DOM_WIDTH as f32)/2.0;
    let ycenter = (DOM_HEIGHT as f32)/2.0;
    for ix in 0..DOM_WIDTH {
        for iy in 0..DOM_HEIGHT {
            let r = DX * distance(xcenter, ycenter, ix as f32, iy as f32);
            let maxr = RADIUS * DX * (1.0+0.3*libm::sin(8.0*libm::atan2(iy as f64-ycenter as f64, ix as f64-xcenter as f64)) as f32);
            phi[ix][iy] += 0.5 + 0.5 * ((maxr - r) / (DX * EPSILON)).tanh();
            bct[ix][iy] +=(ix as f32 - xcenter).tanh().max(0.0).min(1.0);
        }
    }
}

fn initialize_flat(phi: &mut DomainMatrix, bct: &mut DomainMatrix, rng: &mut Pcg64) {
    for ix in 0..DOM_WIDTH {
        for iy in 0..DOM_HEIGHT {
            phi[ix][iy] = 0.5 - 0.5 * (50.0 * (0.5-(iy as f32)/DOM_HEIGHT as f32) / (DX * EPSILON) + 20.0 * (4.0 * 2.0 * f32::consts::PI * ix as f32/DOM_WIDTH as f32).cos()).tanh();
        }
    }
    let xcenter = (DOM_WIDTH as f32)/2.0;
    let ycenter = (DOM_HEIGHT as f32)/2.0;
    // generate_field_circular(phi, xcenter - 25.0, ycenter, RADIUS*DX);
    // generate_field_circular(bct, xcenter, ycenter, RADIUS2*DX);
}

fn f_phi(x: f32) -> f32{
    72.0 * x * (1.0-x) * (x-0.5)
}

fn sum_matrix(u: &DomainMatrix) -> f32 {
    let mut sum = 0.0;
    for ix in 0..DOM_WIDTH {
        for iy in 0..DOM_HEIGHT {
            sum += u[ix][iy];
        }
    }
    sum
}

fn compute_centroid(u: &DomainMatrix) -> (f32, f32) {
    let mut cx = 0.0;
    let mut cy = 0.0;
    for ix in 0..DOM_WIDTH {
        for iy in 0..DOM_HEIGHT {
            cx += u[ix][iy] * ix as f32;
            cy += u[ix][iy] * iy as f32;
        }
    }
    let usum = sum_matrix(u);
    cx /= usum;
    cy /= usum;
    (cx, cy)
}

fn shift_matrix(u: &mut DomainMatrix, sx: i32, sy: i32) {
    let mut newu: DomainMatrix = [[0.0; DOM_HEIGHT]; DOM_WIDTH];
    for ix in 0..(DOM_WIDTH as i32) {
        for iy in 0..(DOM_HEIGHT as i32) {
            if 0 <= ix + sx && ix + sx < DOM_WIDTH as i32 && 0 <= iy + sy && iy + sy < DOM_HEIGHT as i32 {
                newu[ix as usize][iy as usize] = u[(ix+sx) as usize][(iy+sy) as usize];
            }
        }
    }
    *u = newu;
}

fn curvature_factor(c: f32) -> f32 {
    let f = 4.0 * (c - MIN_CURVATURE) / (MAX_CURVATURE - MIN_CURVATURE)
        - 4.0 * (c - MIN_CURVATURE).powi(2) * (MAX_CURVATURE - MIN_CURVATURE).powi(-2);
    f.max(0.0)
}

fn save_images(phi: &DomainMatrix, bct: &DomainMatrix, curv: &DomainMatrix, step: i32) {
    fn f32_to_grayscale_pos(x: f32) -> Rgb<u8> {
        let c = (x*255.0) as u8;
        Rgb([c, c, c])
    }
    // fn f32_to_grayscale(x: f32) -> u8 {
    //     ((x+1.0)/2.0*50.0) as u8
    // }
    fn f32_to_color(x: f32) -> Rgb<u8> {
        if x == 0.0 {return Rgb([0,0,0])};
        let c = x as i32;
        Rgb([((-c.min(0) * 2) as u8).min(255), 64, (c.max(0) as u8 * 2).min(255)])
    }
    let mut image_phi = RgbImage::new(DOM_WIDTH as u32, DOM_HEIGHT as u32);
    let mut image_bct = RgbImage::new(DOM_WIDTH as u32, DOM_HEIGHT as u32);
    let mut image_curv = RgbImage::new(DOM_WIDTH as u32, DOM_HEIGHT as u32);
    for ix in 0..DOM_WIDTH {
        for iy in 0..DOM_HEIGHT {
            image_phi.put_pixel(ix as u32, iy as u32, f32_to_grayscale_pos(phi[ix][iy]));
            image_bct.put_pixel(ix as u32, iy as u32, f32_to_grayscale_pos(bct[ix][iy] * phi[ix][iy]));
            image_curv.put_pixel(ix as u32, iy as u32, f32_to_color(50.0*curv[ix][iy]));
        }
    }
    image_phi.save(format!("out/phi_{:0>6}.png", step/500)).expect("image could not be saved");
    image_bct.save(format!("out/bct_{:0>6}.png", step/500)).expect("image could not be saved");
    image_curv.save(format!("out/curv_{:0>6}.png", step/500)).expect("image could not be saved");
}

fn save_angle_histogram(u: &DomainMatrix) {
    let centroid = compute_centroid(&u);
    let mut hist = [0.0; HISTOGRAM_RESOLUTION];
    let mut count = [0.0; HISTOGRAM_RESOLUTION];
    for ix in 0..DOM_WIDTH {
        for iy in 0..DOM_HEIGHT {
            if u[ix][iy].abs() > THRESHOLD {
                let mut angle = libm::atan2(centroid.0 as f64 - ix as f64, centroid.1 as f64 - iy as f64) as f32;
                angle = angle / (2.0 * f32::consts::PI);
                angle = ((angle * HISTOGRAM_RESOLUTION as f32) + HISTOGRAM_RESOLUTION as f32) % HISTOGRAM_RESOLUTION as f32;
                let angle = angle as usize;
                hist[angle] += u[ix][iy];
                count[angle] += 1.0;
            }
        }
    }
    let mut histogram_file = match OpenOptions::new().append(true).open("out/curv_histogram.txt") {
        Ok(f) => f,
        Err(e) => OpenOptions::new().create_new(true).append(true).open("out/curv_histogram.txt").expect("Error creating file")
    };
    for i in 0..HISTOGRAM_RESOLUTION {
        if count[i] > 0.0 {
            hist[i] /= count[i];
        }
    }
    let hist_as_str = hist.into_iter().map(|x| x.to_string()).collect::<Vec<String>>().join(" ");
    writeln!(histogram_file, "{}", hist_as_str);
}

fn amoeba() {
    let mut rng: Pcg64 = Seeder::from(SEED).make_rng();

    let mut phi: DomainMatrix = [[0.0; DOM_HEIGHT]; DOM_WIDTH];  // Phase field
    let mut bct: DomainMatrix = [[0.0; DOM_HEIGHT]; DOM_WIDTH];  // Concentration
    let mut xi: DomainMatrix = [[0.0; DOM_HEIGHT]; DOM_WIDTH];  // Concentration
    match SHAPE {
        Shape::Circle => initialize_circular(&mut phi, &mut bct, &mut rng),
        Shape::Flat => initialize_flat(&mut phi, &mut bct, &mut rng),
        Shape::BumpyCircle => initialize_bumpy_circle(&mut phi, &mut bct, &mut rng),
    }

    let mut grad_phi: DomainMatrix = [[0.0; DOM_HEIGHT]; DOM_WIDTH];
    let mut lap_phi: DomainMatrix = [[0.0; DOM_HEIGHT]; DOM_WIDTH];
    let mut d_bct_d_phi: DomainMatrix = [[0.0; DOM_HEIGHT]; DOM_WIDTH];
    let mut curv_phi: DomainMatrix = [[0.0; DOM_HEIGHT]; DOM_WIDTH];
    let mut shift: (i32, i32) = (0, 0);
    
    let mut ma2 = MA;
    let mut current_volume = match SHAPE {
        Shape::Circle => VOL,
        Shape::Flat => DOM_HEIGHT as f32 * DOM_WIDTH as f32 / 2.0,
        Shape::BumpyCircle => VOL,
    };
    let mut current_perimeter;
    let amplitude: f32 = (2.0 * SIGMA2 * DT).sqrt() / (DX);
    let mut step = 0;
    let mut time = 0.0;
    let mut delta2 = DELTA02;
    let mut alpha = ALPHA0;
    let mut max_curv = 0.0;
    while time < STOP_TIME {
        step += 1;
        time += DT;
        let target_volume = match SHAPE {
            Shape::Circle => VOL,
            Shape::Flat => DOM_HEIGHT as f32 * DOM_WIDTH as f32 / 2.0,
            Shape::BumpyCircle => VOL,
        };
        ma2 += (DT / TAUMA) * (current_volume - target_volume);

        let mut phi2 = phi.clone();
        let mut bct2 = bct.clone();
        gradient(&phi, &mut grad_phi);
        laplacian(&phi, &mut lap_phi);
        derivate_phase_field(&bct, &phi, &mut d_bct_d_phi);
        if step % 10 == 0 {
            curvature(&phi, &grad_phi, &mut curv_phi, &mut max_curv);
            // if min_curv < -30.0 {alpha = 1.2;}
            // else {alpha = ALPHA0;}
        }

        phi2.par_iter_mut().enumerate().for_each(|(ix, row)| {
        // for ix in 0..DOM_WIDTH {
            for iy in 0..DOM_HEIGHT {
                let phic = phi[ix][iy];
                let bctc = bct[ix][iy];
                let dphidt = 0.0
                    + (GAMMA/TAU) * (f_phi(phic) / EPSILON.powi(2) + lap_phi[ix][iy])
                    - (MB/TAU) * phic * (1.0-phic) * grad_phi[ix][iy]
                    - (ma2/TAU) * grad_phi[ix][iy]
                    // + (alpha/TAU) * bctc * phic * grad_phi[ix][iy] 
                    // - (alpha/TAU) * bctc * phic * grad_phi[ix][iy] * curv_phi[ix][iy]
                    // + (alpha/TAU) * bctc * phic * grad_phi[ix][iy] * curv_phi[ix][iy].powi(2) * 0.005
                    // + 0.5 * (alpha/TAU) * bctc * phic * grad_phi[ix][iy] 
                    // - 8.0 * (alpha/TAU) * bctc * phic * grad_phi[ix][iy] * curvature_factor(curv_phi[ix][iy])
                    + 4.0 * (alpha/TAU) * bctc * phic * grad_phi[ix][iy] * curvature_factor(curv_phi[ix][iy])
                    ;
                row[iy] += dphidt * DT;
                row[iy] = row[iy].min(1.0);
                if row[iy] < 0.00 {
                    // println!("Ostia");
                    // println!("{} {}, phi {} -> {}, bct {} -> {}", ix, iy, phi[ix][iy], row[iy], bct[ix][iy], bct2[ix][iy]);
                    // if true {println!("{} {} {} {}", (GAMMA/TAU) * (f_phi(phic) / EPSILON.powi(2) + lap_phi[ix][iy])
                    //     ,- (MB/TAU) * phic * (1.0-phic) * grad_phi[ix][iy]
                    //     ,- (ma2/TAU) * grad_phi[ix][iy]
                    //     , (alpha/TAU) * bctc * phic * grad_phi[ix][iy]
                    //     )};
                    // println!("{} {} {}", lap_phi[ix][iy], f_phi(phic), EPSILON.powi(2));
                    // return;
                }
            }
        });
        // }
        for ix in 0..DOM_WIDTH {
            for iy in 0..DOM_HEIGHT {
                // DO NOT parallellise this or results will be irreproducible
                xi[ix][iy] = xi[ix][iy] * (1.0 - DT * TAUXI_INV) + amplitude * rng.sample::<f32,_>(StandardNormal);
            }
        }
        bct2.par_iter_mut().enumerate().for_each(|(ix, row)| {
        // for ix in 0..DOM_WIDTH {
            for iy in 0..DOM_HEIGHT {
                let phic = phi[ix][iy];
                let bctc = bct[ix][iy];
                if phic > THRESHOLD {
                    let dbct = 0.0
                        + D_B * d_bct_d_phi[ix][iy] / phic
                        - REACT * DECAYX * bctc
                        - (1.0 - REACT) * phic * xi[ix][iy]
                        + REACT * KACT * bctc * (1.0-bctc) * (bctc - delta2)
                        + MEMBRANE_NOISE * 10.0 * REACT * phic * (1.0-phic) * xi[ix][iy]
                        + GLOBAL_NOISE * phic * xi[ix][iy]
                        + bctc * d_bct_d_phi[ix][iy]
                        ;
                    row[iy] += DT * dbct;
                } else {
                    row[iy] += -DT * bctc * DECAYX;
                }
                row[iy] = row[iy].max(0.0).min(1.0);
            }
        });
        // }
        phi = phi2;
        bct = bct2;
        current_volume = sum_matrix(&phi);
        current_perimeter = sum_matrix(&grad_phi);

        let mut tot = 0.0;
        if step % 100 == 1 {
            if SHIFT_DOMAIN {
                let centroid = compute_centroid(&phi);
                let newshift = (centroid.0 as i32 - (DOM_WIDTH/2) as i32, centroid.1 as i32 - (DOM_HEIGHT/2) as i32);
                shift_matrix(&mut phi, newshift.0, newshift.1);
                shift_matrix(&mut bct, newshift.0, newshift.1);
                shift_matrix(&mut curv_phi, newshift.0, newshift.1);
                shift = (shift.0 + newshift.0, shift.1 + newshift.1);
            }

            tot = 0.0;
            for ix in 0..DOM_WIDTH {
                for iy in 0..DOM_HEIGHT {
                    tot += phi[ix][iy] * bct[ix][iy]
                }
            }
            delta2 = match SHAPE {
                Shape::Circle => delta2 + (DT/TAUDELTA) * (-delta2 + 0.5 + 0.001*(tot-VOL2)),
                Shape::Flat => delta2 + (DT/TAUDELTA) * (-delta2 + 0.5 + 0.001*(tot-VOL2*5.0)),
                Shape::BumpyCircle => delta2 + (DT/TAUDELTA) * (-delta2 + 0.5 + 0.001*(tot-VOL2)),
            };
            delta2 = delta2.min(1.0);
        }

        // if time > 0.1 {break;}
        // println!("\n")
        if step % 100 == 1 {
            save_angle_histogram(&curv_phi);
            let a = 0.0 / 0.0;
            save_images(&phi, &bct, &curv_phi, step);
            let mut log_file = match OpenOptions::new().append(true).open("out/log.txt") {
                Ok(f) => f,
                Err(e) => OpenOptions::new().create_new(true).append(true).open("out/log.txt").expect("Error creating file")
            };
            let logstring = format!("{}. Area: {}, Perimeter: {}, Conc: {}, Delta2: {}, Alpha: {}, Max curv: {}, Shift: ({}, {})",
                     time, current_volume, current_perimeter, tot/current_volume, delta2, alpha, max_curv, shift.0, shift.1);
            println!("{}", logstring);
            log_file.write(logstring.as_bytes());
            let mut shifts_file = match OpenOptions::new().append(true).open("out/shift.txt") {
                Ok(f) => f,
                Err(e) => OpenOptions::new().create_new(true).append(true).open("out/shift.txt").expect("Error creating file")
            };
            shifts_file.write(format!("{} {}\n", shift.0, shift.1).as_bytes()).expect("Write failed");
            let mut time_file = match OpenOptions::new().append(true).open("out/time.txt") {
                Ok(f) => f,
                Err(e) => OpenOptions::new().create_new(true).append(true).open("out/time.txt").expect("Error creating file")
            };
            time_file.write(format!("{}\n", time).as_bytes()).expect("Write failed");
        }
        
    }

}


fn main() {
    amoeba();
}
